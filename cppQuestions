泛型栈

实现一个模板类 Stack<T>，支持基本的栈操作：push、pop 和 top。确保在栈空时 pop 和 top 操作会抛出异常。
多态和虚拟函数

实现一个基类 Shape 和多个派生类（如 Circle、Rectangle）。每个派生类都有一个 area 函数计算其面积。使用多态来调用各个派生类的 area 函数。
智能指针

实现一个简单的智能指针类 MyUniquePtr<T>，类似于 std::unique_ptr，支持基本的所有权管理操作，包括构造、析构、拷贝构造和移动构造。
泛型链表

实现一个模板类 LinkedList<T>，支持基本的链表操作：插入、删除、查找和遍历。确保链表的操作是类型安全的，并且能够处理不同类型的数据。
策略模式

实现一个 SortStrategy 接口和两个策略类 QuickSort 和 MergeSort，用于对数组进行排序。创建一个上下文类 Sorter，使用策略模式来选择不同的排序算法。
迭代器

实现一个自定义容器类 MyVector<T>，包括一个内部迭代器类 MyVectorIterator，可以遍历容器中的元素。确保迭代器符合 C++ 标准库的迭代器要求。
模板元编程

实现一个模板元编程任务，如 Factorial，计算一个整数的阶乘。使用模板特化来处理不同的计算逻辑。
类型特征

实现一个模板结构体 IsPointer，用于检测一个类型是否为指针类型。可以扩展为更复杂的类型特征检测，如是否为整型、浮点型等。





=================================

以下是一些与 STL（标准模板库）相关的面试题目，针对有三年工作经验的 C++ 开发者，重点考察你对 STL 的理解和使用，以及对底层实现的把握：

STL 容器与算法相关的面试题：
std::vector 的底层实现原理

解释 std::vector 是如何管理动态数组的，如何处理内存分配和扩容问题，以及它的时间复杂度。
编写一个简单的 MyVector 类，实现类似 std::vector 的基本功能，包括插入、删除、扩容等操作。
自定义 std::sort 的比较函数

使用 std::sort 对一个自定义结构体的数组进行排序，并编写自定义的比较函数。
解释 std::sort 使用的排序算法是什么？它的时间复杂度是多少？
STL 容器的选择

在下列场景中，如何选择合适的 STL 容器？并解释选择的原因：
频繁插入和删除数据。
需要快速随机访问。
需要维护一个有序的数据集合。
迭代器失效问题

解释在 std::vector、std::list 和 std::map 中，哪些操作会导致迭代器失效？分别举例说明如何避免迭代器失效的问题。
哈希表的实现与 std::unordered_map

解释 std::unordered_map 的底层数据结构，哈希冲突是如何处理的？
编写一个简单的哈希表类，支持插入、查找和删除操作。
实现一个简化版的 std::shared_ptr

编写一个简单的 MySharedPtr 类，模仿 std::shared_ptr 的功能，支持引用计数、自动管理内存以及拷贝和移动语义。
std::map 和 std::unordered_map 的区别

解释 std::map 和 std::unordered_map 的区别，包括底层数据结构、时间复杂度以及适用场景。
如何在 std::map 中自定义排序方式？
自定义分配器

编写一个自定义的分配器类，并使用它为 std::vector 提供内存管理支持。
解释 STL 中的分配器机制，以及在什么情况下需要自定义分配器？
std::list 的底层实现与时间复杂度

解释 std::list 的底层实现以及它的常见操作的时间复杂度。
为什么 std::list 适用于频繁插入和删除元素的场景？
STL 算法的时间复杂度

解释以下 STL 算法的时间复杂度，并说明它们的适用场景：
std::find
std::binary_search
std::lower_bound 和 std::upper_bound
std::accumulate
进阶问题：
容器内部实现的优化

你在 std::vector 或 std::unordered_map 的源码实现中，见过哪些针对性能的优化？这些优化是如何工作的？
如何优化 STL 容器的性能

你在日常工作中，遇到过 STL 容器导致性能瓶颈的情况吗？如何优化或避免这些问题？
这些问题主要考察你对 STL 容器、算法以及它们的底层实现的理解。这类问题在面试中常见，且需要较深的 STL 源码理解能力，适合三年工作经验的开发者准备。你可以通过 mystl 代码的学习，进一步提升对这些问题的掌握。


=========================
下面是一些针对具有三年工作经验的 C++ 开发者的面试代码题目，侧重于考察高级概念、优化以及对 STL、内存管理等更深入的理解：

线程安全的队列

实现一个线程安全的队列类，支持多线程的 push 和 pop 操作。要求使用锁机制或无锁机制。
用模板实现加法和乘法函数

编写一个模板函数，能够对任意类型的输入参数进行加法和乘法运算，确保类型安全，并支持整型、浮点型等基本类型。
实现自定义内存池

实现一个简单的内存池类，用来分配和释放固定大小的内存块，要求提高内存分配效率，避免频繁调用 new 和 delete。
实现一个线程池

实现一个简单的线程池类，支持提交任务并在线程池中执行任务。线程池需要处理任务队列，确保任务的同步和资源的有效利用。
基于二叉树的迭代器实现

实现一个二叉搜索树类 BinarySearchTree，并为其实现前序、中序、后序的迭代器，支持类似于 STL 容器的迭代器使用方式。
实现 RAII 类

实现一个资源管理类，确保通过 RAII（资源获取即初始化）的方式管理资源（如文件、网络连接或内存分配），防止资源泄漏。
提高系统中大量小对象的内存管理效率

给定一个频繁创建和销毁小对象的场景，实现一个自定义的分配器来优化对象的创建和销毁效率。可以参考 std::allocator 进行自定义。
多态工厂模式

实现一个多态的工厂模式，要求基类 Product 和派生类 ConcreteProductA、ConcreteProductB，使用工厂类动态创建这些对象。
多线程条件变量

实现一个生产者-消费者模型，使用 C++11 的条件变量和互斥锁实现，确保生产者和消费者能够正确同步执行。
STL 中的自定义排序

实现一个自定义排序函数，能够对 std::vector<std::pair<int, int>> 进行排序，按第一个元素升序，若第一个元素相同，则按第二个元素降序排序。
这些题目侧重于多线程编程、模板编程、设计模式以及性能优化等高级技能，能够更深入地考察三年工作经验的 C++ 开发者对语言和库的掌握程度。
